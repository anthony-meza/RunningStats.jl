var documenterSearchIndex = {"docs":
[{"location":"api.html#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api.html","page":"API Reference","title":"API Reference","text":"This page provides a comprehensive reference for all functions and types in RunningStats.jl.","category":"page"},{"location":"api.html#Types","page":"API Reference","title":"Types","text":"","category":"section"},{"location":"api.html#WelfordEstimate{T:AbstractFloat}","page":"API Reference","title":"WelfordEstimate{T<:AbstractFloat}","text":"","category":"section"},{"location":"api.html","page":"API Reference","title":"API Reference","text":"Main type for streaming statistical estimates using Welford's algorithm.","category":"page"},{"location":"api.html","page":"API Reference","title":"API Reference","text":"Fields:","category":"page"},{"location":"api.html","page":"API Reference","title":"API Reference","text":"n::Int: Number of samples processed\nmean::Vector{T}: Current mean vector\nM2::Matrix{T}: Sum of squared deviations matrix  \nn_features::Int: Number of features/dimensions","category":"page"},{"location":"api.html","page":"API Reference","title":"API Reference","text":"Constructors:","category":"page"},{"location":"api.html","page":"API Reference","title":"API Reference","text":"WelfordEstimate(): Create with Float64 precision\nWelfordEstimate{Float32}(): Create with Float32 precision\nWelfordEstimate{T}(n_features): Pre-allocate for known feature count","category":"page"},{"location":"api.html#Core-Functions","page":"API Reference","title":"Core Functions","text":"","category":"section"},{"location":"api.html#initialize!(estimator,-n_features)","page":"API Reference","title":"initialize!(estimator, n_features)","text":"","category":"section"},{"location":"api.html","page":"API Reference","title":"API Reference","text":"Initialize estimator for data with known number of features.","category":"page"},{"location":"api.html#update_batch!(estimator,-data_matrix)","page":"API Reference","title":"update_batch!(estimator, data_matrix)","text":"","category":"section"},{"location":"api.html","page":"API Reference","title":"API Reference","text":"Update statistics with a batch of data points. Matrix should be samples × features.","category":"page"},{"location":"api.html","page":"API Reference","title":"API Reference","text":"Returns: Current statistics tuple (count, mean, covariance, correlation, variance)","category":"page"},{"location":"api.html#update_single!(estimator,-sample_vector)","page":"API Reference","title":"update_single!(estimator, sample_vector)","text":"","category":"section"},{"location":"api.html","page":"API Reference","title":"API Reference","text":"Update statistics with a single sample vector.","category":"page"},{"location":"api.html#get_statistics(estimator)","page":"API Reference","title":"get_statistics(estimator)","text":"","category":"section"},{"location":"api.html","page":"API Reference","title":"API Reference","text":"Get all current statistics.","category":"page"},{"location":"api.html","page":"API Reference","title":"API Reference","text":"Returns: Named tuple with fields:","category":"page"},{"location":"api.html","page":"API Reference","title":"API Reference","text":"count: Number of samples processed\nmean: Mean vector\ncovariance: Covariance matrix\ncorrelation: Correlation matrix  \nvariance: Variance vector (diagonal of covariance)","category":"page"},{"location":"api.html#get_covariance(estimator;-correctedtrue)","page":"API Reference","title":"get_covariance(estimator; corrected=true)","text":"","category":"section"},{"location":"api.html","page":"API Reference","title":"API Reference","text":"Get the current covariance matrix.","category":"page"},{"location":"api.html","page":"API Reference","title":"API Reference","text":"Parameters:","category":"page"},{"location":"api.html","page":"API Reference","title":"API Reference","text":"corrected::Bool: Use sample covariance (n-1) vs population (n). Default: true","category":"page"},{"location":"api.html#get_correlation(estimator)","page":"API Reference","title":"get_correlation(estimator)","text":"","category":"section"},{"location":"api.html","page":"API Reference","title":"API Reference","text":"Get the current correlation matrix (standardized covariance).","category":"page"},{"location":"api.html#Merging-Functions","page":"API Reference","title":"Merging Functions","text":"","category":"section"},{"location":"api.html#merge_estimate(est1,-est2)","page":"API Reference","title":"merge_estimate(est1, est2)","text":"","category":"section"},{"location":"api.html","page":"API Reference","title":"API Reference","text":"Combine two estimators into a new estimator (non-destructive).","category":"page"},{"location":"api.html","page":"API Reference","title":"API Reference","text":"Returns: New WelfordEstimate containing merged statistics","category":"page"},{"location":"api.html#merge_estimate!(est1,-est2)","page":"API Reference","title":"merge_estimate!(est1, est2)","text":"","category":"section"},{"location":"api.html","page":"API Reference","title":"API Reference","text":"Merge est2 into est1 (modifies est1 in-place).","category":"page"},{"location":"api.html","page":"API Reference","title":"API Reference","text":"Returns: Modified est1","category":"page"},{"location":"mathematical_background.html#Mathematical-Background","page":"Mathematical Background","title":"Mathematical Background","text":"","category":"section"},{"location":"mathematical_background.html","page":"Mathematical Background","title":"Mathematical Background","text":"This page provides the mathematical foundation for the algorithms implemented in RunningStats.jl.","category":"page"},{"location":"mathematical_background.html#The-Streaming-Statistics-Problem","page":"Mathematical Background","title":"The Streaming Statistics Problem","text":"","category":"section"},{"location":"mathematical_background.html#Traditional-vs-Online-Approaches","page":"Mathematical Background","title":"Traditional vs Online Approaches","text":"","category":"section"},{"location":"mathematical_background.html","page":"Mathematical Background","title":"Mathematical Background","text":"Traditional approach: textData  x_1 x_2 ldots x_n rightarrow textStore all rightarrow textCompute  mu = frac1nsum_i=1^n x_i quad Sigma = frac1n-1sum_i=1^n (x_i-mu)(x_i-mu)^T","category":"page"},{"location":"mathematical_background.html","page":"Mathematical Background","title":"Mathematical Background","text":"Online approach: x_1 rightarrow textUpdate estimates rightarrow x_2 rightarrow textUpdate estimates rightarrow cdots rightarrow textFinal  mu Sigma","category":"page"},{"location":"mathematical_background.html","page":"Mathematical Background","title":"Mathematical Background","text":"The online approach uses O(p²) memory for the algorithm state plus O(batch_size × p) for processing batches, where p is the number of features. The key advantage is that memory usage doesn't grow with the total number of samples processed over time.","category":"page"},{"location":"mathematical_background.html#Welford's-Algorithm-(1962)","page":"Mathematical Background","title":"Welford's Algorithm (1962)","text":"","category":"section"},{"location":"mathematical_background.html#Mathematical-Formulation","page":"Mathematical Background","title":"Mathematical Formulation","text":"","category":"section"},{"location":"mathematical_background.html","page":"Mathematical Background","title":"Mathematical Background","text":"For a sequence of p-dimensional observations mathbfx_1 mathbfx_2 ldots mathbfx_n, Welford's algorithm maintains:","category":"page"},{"location":"mathematical_background.html","page":"Mathematical Background","title":"Mathematical Background","text":"n\n: running count of observations\nboldsymbolmu\n: running mean vector (p times 1)  \nmathbfM_2\n: running sum of outer products matrix (p times p)","category":"page"},{"location":"mathematical_background.html#Recursive-Update-Rules","page":"Mathematical Background","title":"Recursive Update Rules","text":"","category":"section"},{"location":"mathematical_background.html","page":"Mathematical Background","title":"Mathematical Background","text":"For each observation mathbfx_k, the algorithm updates the state recursively:","category":"page"},{"location":"mathematical_background.html","page":"Mathematical Background","title":"Mathematical Background","text":"n_k+1 = n_k + 1","category":"page"},{"location":"mathematical_background.html","page":"Mathematical Background","title":"Mathematical Background","text":"boldsymboldelta_k = mathbfx_k - boldsymbolmu_k","category":"page"},{"location":"mathematical_background.html","page":"Mathematical Background","title":"Mathematical Background","text":"boldsymbolmu_k+1 = boldsymbolmu_k + fracboldsymboldelta_kn_k+1","category":"page"},{"location":"mathematical_background.html","page":"Mathematical Background","title":"Mathematical Background","text":"mathbfM_2k+1 = mathbfM_2k + boldsymboldelta_k(mathbfx_k - boldsymbolmu_k+1)^T","category":"page"},{"location":"mathematical_background.html#Final-Estimates","page":"Mathematical Background","title":"Final Estimates","text":"","category":"section"},{"location":"mathematical_background.html","page":"Mathematical Background","title":"Mathematical Background","text":"From the final accumulated statistics (n_N boldsymbolmu_N mathbfM_2N) after N observations, we can compute:","category":"page"},{"location":"mathematical_background.html","page":"Mathematical Background","title":"Mathematical Background","text":"Sample covariance: boldsymbolSigma_N = fracmathbfM_2Nn_N-1 (Bessel's correction)\nPopulation covariance: boldsymbolSigma_Ntextpop = fracmathbfM_2Nn_N \nSample correlation: mathbfR_N = mathbfD_N^-1boldsymbolSigma_NmathbfD_N^-1 where mathbfD_N = textdiag(sqrtsigma_11 sqrtsigma_22 ldots)\nIndividual variances: textdiag(boldsymbolSigma_N) = (sigma_1N^2 ldots sigma_pN^2)","category":"page"},{"location":"mathematical_background.html#Edge-Cases","page":"Mathematical Background","title":"Edge Cases","text":"","category":"section"},{"location":"mathematical_background.html","page":"Mathematical Background","title":"Mathematical Background","text":"Empty estimator (n_0 = 0): Returns empty matrices/vectors\nSingle sample (n_1 = 1): Sample covariance is undefined (NaN), population covariance is zero matrix\nZero variance: Correlation computation handles sigma_iiN = 0 by treating as sigma_iiN = 1 to avoid division by zero","category":"page"},{"location":"mathematical_background.html#Numerical-Stability","page":"Mathematical Background","title":"Numerical Stability","text":"","category":"section"},{"location":"mathematical_background.html","page":"Mathematical Background","title":"Mathematical Background","text":"Traditional \"textbook\" variance formula sigma^2 = EX^2 - (EX)^2 suffers from catastrophic cancellation when EX^2 approx (EX)^2. Welford's algorithm avoids this by:","category":"page"},{"location":"mathematical_background.html","page":"Mathematical Background","title":"Mathematical Background","text":"Computing deviations from running mean rather than raw second moments\nUsing the mathematically equivalent but numerically stable recurrence relation","category":"page"},{"location":"mathematical_background.html","page":"Mathematical Background","title":"Mathematical Background","text":"Stability comparison:","category":"page"},{"location":"mathematical_background.html","page":"Mathematical Background","title":"Mathematical Background","text":"Naive: sigma^2 = fracsum x^2n - left(fracsum xnright)^2 → susceptible to cancellation  \nWelford: sigma^2 = fracM_2n-1 where M_2 accumulates (x-mu)^2 → numerically stable","category":"page"},{"location":"mathematical_background.html#Chan's-Parallel-Algorithm-(1983)","page":"Mathematical Background","title":"Chan's Parallel Algorithm (1983)","text":"","category":"section"},{"location":"mathematical_background.html#The-Merging-Problem","page":"Mathematical Background","title":"The Merging Problem","text":"","category":"section"},{"location":"mathematical_background.html","page":"Mathematical Background","title":"Mathematical Background","text":"Given two sets of statistics computed independently:","category":"page"},{"location":"mathematical_background.html","page":"Mathematical Background","title":"Mathematical Background","text":"Stream A: (n_A boldsymbolmu_A mathbfM_2A) from observations mathbfx_1 mathbfx_2 ldots mathbfx_n_A\nStream B: (n_B boldsymbolmu_B mathbfM_2B) from observations mathbfy_1 mathbfy_2 ldots mathbfy_n_B","category":"page"},{"location":"mathematical_background.html","page":"Mathematical Background","title":"Mathematical Background","text":"Find the equivalent statistics (n_A+B boldsymbolmu_A+B mathbfM_2A+B) for the combined sequence mathbfx_1 ldots mathbfx_n_A mathbfy_1 ldots mathbfy_n_B.","category":"page"},{"location":"mathematical_background.html#Chan's-Solution","page":"Mathematical Background","title":"Chan's Solution","text":"","category":"section"},{"location":"mathematical_background.html","page":"Mathematical Background","title":"Mathematical Background","text":"The exact merged statistics are computed as:","category":"page"},{"location":"mathematical_background.html","page":"Mathematical Background","title":"Mathematical Background","text":"n_A+B = n_A + n_B","category":"page"},{"location":"mathematical_background.html","page":"Mathematical Background","title":"Mathematical Background","text":"boldsymboldelta_AB = boldsymbolmu_B - boldsymbolmu_A","category":"page"},{"location":"mathematical_background.html","page":"Mathematical Background","title":"Mathematical Background","text":"boldsymbolmu_A+B = boldsymbolmu_A + boldsymboldelta_ABfracn_Bn_A+B","category":"page"},{"location":"mathematical_background.html","page":"Mathematical Background","title":"Mathematical Background","text":"mathbfM_2A+B = mathbfM_2A + mathbfM_2B + boldsymboldelta_ABboldsymboldelta_AB^Tfracn_A n_Bn_A+B","category":"page"},{"location":"mathematical_background.html#Algorithm-Implementation","page":"Mathematical Background","title":"Algorithm Implementation","text":"","category":"section"},{"location":"mathematical_background.html","page":"Mathematical Background","title":"Mathematical Background","text":"The merging process handles several edge cases:","category":"page"},{"location":"mathematical_background.html","page":"Mathematical Background","title":"Mathematical Background","text":"Empty source (n_B = 0): Result equals target (n_A boldsymbolmu_A mathbfM_2A)\nEmpty target (n_A = 0): Target becomes copy of source (n_B boldsymbolmu_B mathbfM_2B)\nDimension mismatch: Throws DimensionMismatch if feature counts differ\nNumerical precision: All operations maintain the numerical stability of underlying Welford updates","category":"page"},{"location":"mathematical_background.html#Properties","page":"Mathematical Background","title":"Properties","text":"","category":"section"},{"location":"mathematical_background.html","page":"Mathematical Background","title":"Mathematical Background","text":"Exactness: Merged result is identical to processing all data together\nAssociativity: Order of merging doesn't matter\nNumerical stability: Inherits stability properties from underlying Welford updates","category":"page"},{"location":"mathematical_background.html#Applications","page":"Mathematical Background","title":"Applications","text":"","category":"section"},{"location":"mathematical_background.html","page":"Mathematical Background","title":"Mathematical Background","text":"Map-reduce: Process data chunks on different machines, merge results\nHierarchical computation: Combine statistics from organizational units\nStreaming aggregation: Merge statistics from different time windows","category":"page"},{"location":"mathematical_background.html#Complexity-Analysis","page":"Mathematical Background","title":"Complexity Analysis","text":"","category":"section"},{"location":"mathematical_background.html#Memory-Complexity","page":"Mathematical Background","title":"Memory Complexity","text":"","category":"section"},{"location":"mathematical_background.html","page":"Mathematical Background","title":"Mathematical Background","text":"Algorithm state: O(p^2) where p is the number of features\nSingle updates: O(p^2) total (only stores current state)\nBatch updates: O(p^2 + textbatch_size times p) during processing\nKey advantage: Memory doesn't grow with total number of samples over time","category":"page"},{"location":"mathematical_background.html#Time-Complexity","page":"Mathematical Background","title":"Time Complexity","text":"","category":"section"},{"location":"mathematical_background.html","page":"Mathematical Background","title":"Mathematical Background","text":"Per sample: O(p^2) for Welford update\nPer batch: O(textbatch_size times p^2) \nMerging: O(p^2) to combine two estimators","category":"page"},{"location":"mathematical_background.html#Numerical-Stability-2","page":"Mathematical Background","title":"Numerical Stability","text":"","category":"section"},{"location":"mathematical_background.html","page":"Mathematical Background","title":"Mathematical Background","text":"Uses Welford's algorithm for stable computation\nAvoids catastrophic cancellation in variance computations\nSuitable for streaming applications with millions of samples","category":"page"},{"location":"mathematical_background.html#References","page":"Mathematical Background","title":"References","text":"","category":"section"},{"location":"mathematical_background.html","page":"Mathematical Background","title":"Mathematical Background","text":"Welford, B. P. (1962). \"Note on a method for calculating corrected sums of squares and products.\" Technometrics, 4(3), 419-420.\nChan, T. F., Golub, G. H., & LeVeque, R. J. (1983). \"Algorithms for computing the sample variance: Analysis and recommendations.\" The American Statistician, 37(3), 242-247.\nKnuth, D. E. (1998). The Art of Computer Programming, Volume 2: Seminumerical Algorithms (3rd ed.). Addison-Wesley.","category":"page"},{"location":"examples.html#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"This page provides practical examples of using RunningStats.jl.","category":"page"},{"location":"examples.html#Basic-Usage","page":"Examples","title":"Basic Usage","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"using RunningStats\nusing Random\n\n# Create an estimator\nestimator = WelfordEstimate()\n\n# Simulate getting data in batches\nRandom.seed!(42)\nbatch1 = randn(100, 3)  # First batch: 100 rows, 3 columns\nbatch2 = randn(50, 3)   # Second batch: 50 more rows\n\n# Process first batch\nstats1 = update_batch!(estimator, batch1)\nprintln(\"Processed $(stats1.count) samples\")\nprintln(\"Current mean: $(round.(stats1.mean, digits=2))\")\n\n# Process second batch - statistics automatically update\nstats2 = update_batch!(estimator, batch2)\nprintln(\"Now processed $(stats2.count) total samples\")\nprintln(\"Updated mean: $(round.(stats2.mean, digits=2))\")","category":"page"},{"location":"examples.html#Comparing-with-Standard-Julia","page":"Examples","title":"Comparing with Standard Julia","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"using Statistics\n\n# Generate test data\ndata = randn(1000, 3)\n\n# Method 1: Standard Julia (requires storing all data)\njulia_mean = mean(data, dims=1)[:]\njulia_cov = cov(data)\n\n# Method 2: RunningStats (streaming)\nestimator = WelfordEstimate()\nupdate_batch!(estimator, data)\nrunning_stats = get_statistics(estimator)\n\n# Compare results - should be identical\nprintln(\"Mean difference: $(maximum(abs.(julia_mean - running_stats.mean)))\")\nprintln(\"Covariance difference: $(maximum(abs.(julia_cov - running_stats.covariance)))\")","category":"page"},{"location":"examples.html#Updating-with-New-Data","page":"Examples","title":"Updating with New Data","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"# Suppose new data arrives later...\nnew_data = randn(500, 3)\n\n# Standard Julia: Need to combine and recompute everything  \nall_data = vcat(data, new_data)\njulia_mean_updated = mean(all_data, dims=1)[:]\njulia_cov_updated = cov(all_data)\n\n# RunningStats: Just update the existing estimator\nupdate_batch!(estimator, new_data)\nupdated_stats = get_statistics(estimator)\n\n# Results are still identical, but RunningStats never stored the original data!\nprintln(\"Updated mean difference: $(maximum(abs.(julia_mean_updated - updated_stats.mean)))\")","category":"page"},{"location":"examples.html#Merging-Statistics","page":"Examples","title":"Merging Statistics","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"# Process data from different sources\nsource1 = WelfordEstimate()  \nsource2 = WelfordEstimate()\n\nupdate_batch!(source1, randn(200, 4))\nupdate_batch!(source2, randn(300, 4))\n\n# Combine the results (two ways)\ncombined = merge_estimate(source1, source2)    # Creates new estimator\nmerge_estimate!(source1, source2)             # Modifies source1 in-place\n\nstats = get_statistics(combined)\nprintln(\"Combined statistics from $(stats.count) total samples\")","category":"page"},{"location":"examples.html#Parallel-Processing","page":"Examples","title":"Parallel Processing","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"using Distributed\n\n# Function to process a data partition\nfunction process_partition(data_chunk)\n    est = WelfordEstimate()\n    update_batch!(est, data_chunk)\n    return est\nend\n\n# Split data across workers (simulated)\ndata_partitions = [randn(250, 3) for _ in 1:4]\nestimator_results = map(process_partition, data_partitions)\n\n# Merge all results\nfinal_estimator = reduce(merge_estimate, estimator_results)\nfinal_stats = get_statistics(final_estimator)\n\nprintln(\"Processed $(final_stats.count) samples in parallel\")","category":"page"},{"location":"index.html#RunningStats.jl","page":"Home","title":"RunningStats.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Efficient computation of streaming statistics using numerically stable online algorithms.","category":"page"},{"location":"index.html#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"RunningStats.jl provides tools for computing statistics on data streams without storing the entire dataset in memory. This is particularly useful for:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Large datasets that don't fit in memory\nReal-time streaming applications  \nParallel and distributed computing\nMemory-constrained environments","category":"page"},{"location":"index.html#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"using RunningStats\n\n# Create an estimator\nestimator = WelfordEstimate()\n\n# Process data in chunks\nupdate_batch!(estimator, randn(1000, 3))\nupdate_batch!(estimator, randn(500, 3))\n\n# Get results\nstats = get_statistics(estimator)\nprintln(\"Mean: \", stats.mean)\nprintln(\"Covariance diagonal: \", stats.variance)","category":"page"},{"location":"index.html#Key-Features","page":"Home","title":"Key Features","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Memory Efficient: O(p²) space complexity, independent of sample size\nNumerically Stable: Uses Welford's algorithm to avoid catastrophic cancellation\nParallel Friendly: Implements Chan's algorithm for merging statistics\nType Flexible: Supports different floating-point precisions","category":"page"},{"location":"index.html#Package-Contents","page":"Home","title":"Package Contents","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\"mathematical_background.md\", \"api.md\", \"examples.md\"]","category":"page"}]
}
